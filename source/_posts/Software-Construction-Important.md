title: Software Construction
date: 2015-09-06 16:26:14
tags:
- CODE COMPLETE
- all
---
> #Software Construction
 
***
***

##软件开发平面图
####构建活动中的具体任务
* 验证有关的基础工作已经完成.因此构建活动才得以顺利的进行下去。
    如,需求分析
*  确定如何测试所写的代码
*  编码实现
*  代码的单元测试，代码的集成测试，已经代码评审
*  代码格式化合注释
*  调整代码,让他更快，更省资源
![软甲开发平面图](/imgs/software-develop/software_developer01.png)
***

##软件构建活动与非构建活动
1.  ###非构建活动
    ####1.1 管理
    ####1.2 需求分析
    ####1.3 用户界面设计
    ####1.4 系统测试
    ####1.5 维护
    
2.  ###构建活动
    ####2.1 详细设计
    ####2.2 编码实现
    ####2.3 调试
    ####2.4 集成
    ####2.5 开发者测试

***    
##你对如何进行构建的理解程度,决定了你这名程序员的优秀程度。
1.  明确需求分析,关键点，在未开始构建之前,就已经知道构建之后是什么样子了(包括如何使用，如何扩展等等).

2.  构建之中,系统核心功能为主干，需要先明确以及验证是否达到需求目标。而后完善功能细节。
    * 存在于世界上的任何逻辑,都依托于某种最基本的东西。
    * 比如,盖房子需要先打地基,研发汽车需要合适的发动机，等等。软件模块间的数据流动，需要先明确接口。
    * 一个软件模块，必定基于某种技术为主干。而后在此主干上细化和实现功能分支。及需要开发一个最小原形来验证,设计的合理性以及可行性。
    * 基于以上验证，进行功能的开发,so easy.
    * 随着开发，如果感觉到，实现越来越复杂，以及不确定性。此刻需要考虑到重构。软甲结构的调整。
    
3.  构建中的哲学,无论什么模块或系统,在编码和调试过程中,需要的是
    * 随着时间的推移,随着整个模块/系统的完成度越来越高,程序员会感到各种功能实现越发容易。而非越来越难.
      如果越来简单,开发越容易,那么至少软件架构合理,易于维护。
      如果越到越难,开发越艰难,那么我么是时候重构代码.重新设计一下模块结构.
    
***
##软件中的隐喻
1.  ####你对隐喻有多理解,也决定了你对软开发有多理解

2.  ####常见隐喻
    1. Software Penmanship: Writing Code 软件中的书法:写作代码
    2. Software Farming: Growing a System 软件的耕作法:培植系统
    3. Software Oyster Farming: System Accretion 软件的牡蛎养殖观点: 系统生长
     * 你需要学会如何一次为软件系统增加一个小部分
       增量的(incremental),迭代的(iterative),自适应的(adaptive),演进的(evolutionary)
     * 在进行增量式开发时,我们先做出软件系统的一个尽可能简单的,能够运行的版本,它不必接受真实
       的输入,也无须对数据进行真正的处理,更不用产生真实的输，它仅仅需要构建一个足够强壮的骨架
       支撑起未来开发的真实系统。对于你标志出来的每一个真实功能,可能仅仅需要调用虚假类(dummy classes).
     * 这个最基本的起点,就像牡蛎开始孕育珍珠的那颗细小沙粒。
       在骨架形成之后,你要一点点在其上附着肌肉和皮肤。将骨架中虚假的类,一点点替换。完成整个构建。
       你一次次增加一小段代码,直到得到一个完全可以工作的系统.
      
    4. Software Construction: Building Software 软件构建:建造软件
    
     * 更复杂的结构,需要更加仔细的规划
       在2.3的基础上,增加更详尽的计划。体检计划，运筹帷幄，然后在行动
     * 精心的计划,并非意味着事无巨细的计划或者过度计划,你可以把房屋机构性的支撑(structural support)
       规划清楚,而在日后再决定使用木地板还是地毯。
    5. Applying Software Techniques: The Intellectual Toolbox 应用软件技术:智慧工具箱
     * 技术并不是规矩,它只是分析工具。
     
    6. Combining Metaphors 组合各个隐喻
     * 隐喻是一种启发式方法而不是算法，因此他们彼此并不排斥。
     * 使用隐喻有是件说不清楚的事情,你需要适当的引申它的含义,才能从其蕴含的深刻启发中受益。
     
    7. KeyPoints
     * 隐喻是启示不是算法,因此他们往往有一点随意。
     * 隐喻把软件开发过程和你熟悉的活动联系在一起,帮助你更好的理解。
     * 有些隐喻别其他一些隐喻更加贴切。
     * 通过把软件的构建过程比喻成房屋的建设过程,我们可以发现,仔细的准备是必要的，而大型项目和
       小型项目之间也是有差别的。
     * 通过把软件开发中的实践比作是智慧工具箱中的工具,我们有发现,每位程序员都有许多
       工具,因地制宜的选择正确工具,但并不存在于一个能适应所有工作的工具,因地制宜的选择正确工具,
       是成为能有效变成的程序员的关键。
     * 不同隐喻彼此并不排斥,应当使用对你最有益处的某种隐喻组合。
     
    999. Software is like a War.逐步推进,知己知彼,关键节点打通。
    然而,战争关键节点往往是地理位置,它是已知的。软件开发的关键节点需要经验和反复验证。

***
***
引用书籍:
###1. [CODE COMPLETE 代码大全](http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%B2%E8%92%82%E5%A4%AB%E2%80%A2%E8%BF%88%E5%85%8B%E5%BA%B7%E5%A5%88%E5%B0%94/dp/B0061XKRXA/ref=sr_1_1?ie=UTF8&qid=1441693546&sr=8-1&keywords=%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8)
